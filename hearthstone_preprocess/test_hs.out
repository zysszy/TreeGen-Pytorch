class Archmage(MinionCard):§    def __init__(self):§        super().__init__("Archmage", 6, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(4, 7, spell_damage=1)§
class BootyBayBodyguard(MinionCard):§    def __init__(self):§        super().__init__("Booty Bay Bodyguard", 5, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(5, 4, taunt=True)§
class DarkscaleHealer(MinionCard):§    def __init__(self):§        super().__init__("Darkscale Healer", 5, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, battlecry=Battlecry(Heal(2), CharacterSelector()))§§    def create_minion(self, player):§        return Minion(4, 5)§
class FieryWarAxe(WeaponCard):§    def __init__(self):§        super().__init__("Fiery War Axe", 2, CHARACTER_CLASS.WARRIOR, CARD_RARITY.FREE)§§    def create_weapon(self, player):§        return Weapon(3, 2)§
class FrostwolfWarlord(MinionCard):§    def __init__(self):§        super().__init__("Frostwolf Warlord", 5, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, battlecry=Battlecry(Give([Buff(ChangeAttack(Count(MinionSelector()))), Buff(ChangeHealth(Count(MinionSelector())))]), SelfSelector()))§§    def create_minion(self, player):§        return Minion(4, 4)§
class Hellfire(SpellCard):§    def __init__(self):§        super().__init__("Hellfire", 4, CHARACTER_CLASS.WARLOCK, CARD_RARITY.FREE)§§    def use(self, player, game):§        super().use(player, game)§        targets = copy.copy(game.other_player.minions)§        targets.extend(game.current_player.minions)§        targets.append(game.other_player.hero)§        targets.append(game.current_player.hero)§        for minion in targets:§            minion.damage(player.effective_spell_damage(3), self)§
class Innervate(SpellCard):§    def __init__(self):§        super().__init__("Innervate", 0, CHARACTER_CLASS.DRUID, CARD_RARITY.FREE)§§    def use(self, player, game):§        super().use(player, game)§        if player.mana < 8:§            player.mana += 2§        else:§            player.mana = 10§
class MagmaRager(MinionCard):§    def __init__(self):§        super().__init__("Magma Rager", 3, CHARACTER_CLASS.ALL, CARD_RARITY.FREE)§§    def create_minion(self, player):§        return Minion(5, 1)§
class MortalCoil(SpellCard):§    def __init__(self):§        super().__init__("Mortal Coil", 1, CHARACTER_CLASS.WARLOCK, CARD_RARITY.COMMON, target_func=hearthbreaker.targeting.find_minion_spell_target)§§    def use(self, player, game):§        super().use(player, game)§        if self.target.health <= player.effective_spell_damage(1) and not self.target.divine_shield:§            self.target.damage(player.effective_spell_damage(1), self)§            player.draw()§        else:§            self.target.damage(player.effective_spell_damage(1), self)§
class Polymorph(SpellCard):§    def __init__(self):§        super().__init__("Polymorph", 4, CHARACTER_CLASS.MAGE, CARD_RARITY.FREE, target_func=hearthbreaker.targeting.find_minion_spell_target)§§    def use(self, player, game):§        super().use(player, game)§        from hearthbreaker.cards.minions.mage import Sheep§        sheep = Sheep()§        minion = sheep.create_minion(None)§        minion.card = sheep§        self.target.replace(minion)§
class SearingTotem(MinionCard):§    def __init__(self):§        super().__init__("Searing Totem", 1, CHARACTER_CLASS.SHAMAN, CARD_RARITY.FREE, False, MINION_TYPE.TOTEM)§§    def create_minion(self, player):§        return Minion(1, 1)§
class SilverbackPatriarch(MinionCard):§    def __init__(self):§        super().__init__("Silverback Patriarch", 3, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, minion_type=MINION_TYPE.BEAST)§§    def create_minion(self, player):§        return Minion(1, 4, taunt=True)§
class StormwindKnight(MinionCard):§    def __init__(self):§        super().__init__("Stormwind Knight", 4, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(2, 5, charge=True)§
class VoodooDoctor(MinionCard):§    def __init__(self):§        super().__init__("Voodoo Doctor", 1, CHARACTER_CLASS.ALL, CARD_RARITY.FREE, battlecry=Battlecry(Heal(2), CharacterSelector(players=BothPlayer(), picker=UserPicker())))§§    def create_minion(self, player):§        return Minion(2, 1)§
class WrathOfAirTotem(MinionCard):§    def __init__(self):§        super().__init__("Wrath of Air Totem", 1, CHARACTER_CLASS.SHAMAN, CARD_RARITY.FREE, False, MINION_TYPE.TOTEM)§§    def create_minion(self, player):§        return Minion(0, 2, spell_damage=1)§
class AstralCommunion(SpellCard):§    def __init__(self):§        super().__init__("Astral Communion", 4, CHARACTER_CLASS.DRUID, CARD_RARITY.EPIC)§§    def use(self, player, game):§        super().use(player, game)§        for card in player.hand:§            card.unattach()§            player.trigger("card_discarded", card)§        player.hand = []§        player.max_mana = 10§        player.mana = 10§
class AnnoyoTron(MinionCard):§    def __init__(self):§        super().__init__("Annoy-o-Tron", 2, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, minion_type=MINION_TYPE.MECH)§§    def create_minion(self, player):§        return Minion(1, 2, divine_shield=True, taunt=True)§
class BurlyRockjawTrogg(MinionCard):§    def __init__(self):§        super().__init__("Burly Rockjaw Trogg", 4, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(3, 5, effects=[Effect(SpellCast(player=EnemyPlayer()), ActionTag(Give(ChangeAttack(2)), SelfSelector()))])§
class CogmastersWrench(WeaponCard):§    def __init__(self):§        super().__init__("Cogmaster's Wrench", 3, CHARACTER_CLASS.ROGUE, CARD_RARITY.EPIC)§§    def create_weapon(self, player):§        return Weapon(1, 3, buffs=[Buff(ChangeAttack(2), GreaterThan(Count(MinionSelector(IsType(MINION_TYPE.MECH))), value=0))])§
class EchoOfMedivh(SpellCard):§    def __init__(self):§        super().__init__("Echo of Medivh", 4, CHARACTER_CLASS.MAGE, CARD_RARITY.EPIC)§§    def use(self, player, game):§        super().use(player, game)§        for minion in sorted(copy.copy(player.minions), key=lambda minion: minion.born):§            if len(player.hand) < 10:§                player.hand.append(minion.card)§
class FloatingWatcher(MinionCard):§    def __init__(self):§        super().__init__("Floating Watcher", 5, CHARACTER_CLASS.WARLOCK, CARD_RARITY.COMMON, minion_type=MINION_TYPE.DEMON)§§    def create_minion(self, player):§        return Minion(4, 4, effects=[Effect(CharacterDamaged(And(IsHero(), OwnersTurn())), ActionTag(Give([Buff(ChangeAttack(2)), Buff(ChangeHealth(2))]), SelfSelector()))])§
class GnomishExperimenter(MinionCard):§    def __init__(self):§        super().__init__("Gnomish Experimenter", 3, CHARACTER_CLASS.ALL, CARD_RARITY.RARE, battlecry=(Battlecry(Draw(), PlayerSelector()), Battlecry(Transform(GnomishChicken()), LastDrawnSelector(), Matches(LastDrawnSelector(), IsMinion()))))§§    def create_minion(self, player):§        return Minion(3, 2)§
class IronJuggernaut(MinionCard):§    def __init__(self):§        super().__init__("Iron Juggernaut", 6, CHARACTER_CLASS.WARRIOR, CARD_RARITY.LEGENDARY, minion_type=MINION_TYPE.MECH, battlecry=Battlecry(AddCard(BurrowingMine(), add_to_deck=True), PlayerSelector(EnemyPlayer())))§§    def create_minion(self, player):§        return Minion(6, 5)§
class MadderBomber(MinionCard):§    def __init__(self):§        super().__init__("Madder Bomber", 5, CHARACTER_CLASS.ALL, CARD_RARITY.RARE, battlecry=Battlecry(Damage(1), CharacterSelector(players=BothPlayer(), picker=RandomPicker(6))))§§    def create_minion(self, player):§        return Minion(5, 4)§
class MiniMage(MinionCard):§    def __init__(self):§        super().__init__("Mini-Mage", 4, CHARACTER_CLASS.ALL, CARD_RARITY.EPIC)§§    def create_minion(self, player):§        return Minion(4, 1, stealth=True, spell_damage=1)§
class PilotedSkyGolem(MinionCard):§    def __init__(self):§        super().__init__("Piloted Sky Golem", 6, CHARACTER_CLASS.ALL, CARD_RARITY.EPIC, minion_type=MINION_TYPE.MECH)§§    def create_minion(self, player):§        return Minion(6, 4, deathrattle=Deathrattle(Summon(CardQuery(conditions=[ManaCost(4), IsMinion()])), PlayerSelector()))§
class ScarletPurifier(MinionCard):§    def __init__(self):§        super().__init__("Scarlet Purifier", 3, CHARACTER_CLASS.PALADIN, CARD_RARITY.RARE, battlecry=Battlecry(Damage(2), MinionSelector(MinionHasDeathrattle(), BothPlayer())))§§    def create_minion(self, player):§        return Minion(4, 3)§
class SiltfinSpiritwalker(MinionCard):§    def __init__(self):§        super().__init__("Siltfin Spiritwalker", 4, CHARACTER_CLASS.SHAMAN, CARD_RARITY.EPIC, minion_type=MINION_TYPE.MURLOC, overload=1)§§    def create_minion(self, player):§        return Minion(2, 5, effects=[Effect(MinionDied(IsType(MINION_TYPE.MURLOC)), ActionTag(Draw(), PlayerSelector()))])§
class TinkertownTechnician(MinionCard):§    def __init__(self):§        from hearthbreaker.cards.spells.neutral import spare_part_list§        super().__init__("Tinkertown Technician", 3, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, battlecry=(Battlecry(Give([Buff(ChangeAttack(1)), Buff(ChangeHealth(1))]), SelfSelector(), GreaterThan(Count(MinionSelector(IsType(MINION_TYPE.MECH))), value=0)), Battlecry(AddCard(CardQuery(source=CARD_SOURCE.LIST, source_list=spare_part_list)), PlayerSelector(), GreaterThan(Count(MinionSelector(IsType(MINION_TYPE.MECH))), value=0))))§§    def create_minion(self, player):§        return Minion(3, 3)§
class Voljin(MinionCard):§    def __init__(self):§        super().__init__("Vol'jin", 5, CHARACTER_CLASS.PRIEST, CARD_RARITY.LEGENDARY, battlecry=Battlecry(SwapStats("health", "health", True), MinionSelector(players=BothPlayer(), picker=UserPicker())))§§    def create_minion(self, player):§        return Minion(6, 2)§
class DeathsBite(WeaponCard):§    def __init__(self):§        super().__init__("Death's Bite", 4, CHARACTER_CLASS.WARRIOR, CARD_RARITY.COMMON)§§    def create_weapon(self, player):§        return Weapon(4, 2, deathrattle=Deathrattle(Damage(1), MinionSelector(players=BothPlayer())))§
class Maexxna(MinionCard):§    def __init__(self):§        super().__init__("Maexxna", 6, CHARACTER_CLASS.ALL, CARD_RARITY.LEGENDARY, minion_type=MINION_TYPE.BEAST)§§    def create_minion(self, player):§        return Minion(2, 8, effects=[Effect(DidDamage(), ActionTag(Kill(), TargetSelector(IsMinion())))])§
class SludgeBelcher(MinionCard):§    def __init__(self):§        super().__init__("Sludge Belcher", 5, CHARACTER_CLASS.ALL, CARD_RARITY.RARE)§§    def create_minion(self, player):§        return Minion(3, 5, taunt=True, deathrattle=Deathrattle(Summon(Slime()), PlayerSelector()))§
class Voidcaller(MinionCard):§    def __init__(self):§        super().__init__("Voidcaller", 4, CHARACTER_CLASS.WARLOCK, CARD_RARITY.COMMON, minion_type=MINION_TYPE.DEMON)§§    def create_minion(self, player):§        return Minion(3, 4, deathrattle=Deathrattle(Summon(CardQuery(conditions=[IsType(MINION_TYPE.DEMON)], source=CARD_SOURCE.MY_HAND)), PlayerSelector()))§
class Alexstrasza(MinionCard):§    def __init__(self):§        super().__init__("Alexstrasza", 9, CHARACTER_CLASS.ALL, CARD_RARITY.LEGENDARY, minion_type=MINION_TYPE.DRAGON, battlecry=Battlecry(SetHealth(15), HeroSelector(players=BothPlayer(), picker=UserPicker())))§§    def create_minion(self, player):§        return Minion(8, 8)§
class ArcaneGolem(MinionCard):§    def __init__(self):§        super().__init__("Arcane Golem", 3, CHARACTER_CLASS.ALL, CARD_RARITY.RARE, battlecry=Battlecry(GiveManaCrystal(), PlayerSelector(players=EnemyPlayer())))§§    def create_minion(self, player):§        return Minion(4, 2, charge=True)§
class BaineBloodhoof(MinionCard):§    def __init__(self):§        super().__init__("Baine Bloodhoof", 4, CHARACTER_CLASS.ALL, CARD_RARITY.LEGENDARY, False)§§    def create_minion(self, player):§        return Minion(4, 5)§
class BladeFlurry(SpellCard):§    def __init__(self):§        super().__init__("Blade Flurry", 2, CHARACTER_CLASS.ROGUE, CARD_RARITY.RARE)§§    def use(self, player, game):§        super().use(player, game)§§        if player.weapon is not None:§            attack_power = player.effective_spell_damage(player.hero.calculate_attack())§            player.weapon.destroy()§§            for minion in copy.copy(game.other_player.minions):§                minion.damage(attack_power, self)§§            game.other_player.hero.damage(attack_power, self)§
class Brawl(SpellCard):§    def __init__(self):§        super().__init__("Brawl", 5, CHARACTER_CLASS.WARRIOR, CARD_RARITY.EPIC)§§    def can_use(self, player, game):§        return super().can_use(player, game) and len(player.minions) + len(player.opponent.minions) >= 2§§    def use(self, player, game):§        super().use(player, game)§§        minions = copy.copy(player.minions)§        minions.extend(game.other_player.minions)§§        if len(minions) > 1:§            survivor = game.random_choice(minions)§            for minion in minions:§                if minion is not survivor:§                    minion.die(self)§
class Conceal(SpellCard):§    def __init__(self):§        super().__init__("Conceal", 1, CHARACTER_CLASS.ROGUE, CARD_RARITY.COMMON)§§    def use(self, player, game):§        super().use(player, game)§        for minion in player.minions:§            if not minion.stealth:§                minion.add_buff(BuffUntil(Stealth(), TurnStarted()))§
class DefenderMinion(MinionCard):§    def __init__(self):§        super().__init__("Defender", 1, CHARACTER_CLASS.PALADIN, CARD_RARITY.COMMON)§§    def create_minion(self, p):§        return Minion(2, 1)§
class Doomguard(MinionCard):§    def __init__(self):§        super().__init__("Doomguard", 5, CHARACTER_CLASS.WARLOCK, CARD_RARITY.RARE, minion_type=MINION_TYPE.DEMON, battlecry=Battlecry(Discard(amount=2), PlayerSelector()))§§    def create_minion(self, player):§        return Minion(5, 7, charge=True)§
class EarthElemental(MinionCard):§    def __init__(self):§        super().__init__("Earth Elemental", 5, CHARACTER_CLASS.SHAMAN, CARD_RARITY.EPIC, overload=3)§§    def create_minion(self, player):§        return Minion(7, 8, taunt=True)§
class ExplosiveTrap(SecretCard):§    def __init__(self):§        super().__init__("Explosive Trap", 2, CHARACTER_CLASS.HUNTER, CARD_RARITY.COMMON)§§    def activate(self, player):§        player.opponent.bind("character_attack", self._reveal)§§    def deactivate(self, player):§        player.opponent.unbind("character_attack", self._reveal)§§    def _reveal(self, attacker, target):§        if isinstance(target, Hero):§            game = attacker.player.game§            enemies = copy.copy(game.current_player.minions)§            enemies.append(game.current_player.hero)§            for enemy in enemies:§                enemy.damage(2, None)§            game.check_delayed()§            super().reveal()§
class FlameOfAzzinoth(MinionCard):§    def __init__(self):§        super().__init__("Flame of Azzinoth", 1, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, False)§§    def create_minion(self, player):§        return Minion(2, 1)§
class Gnoll(MinionCard):§    def __init__(self):§        super().__init__("Gnoll", 2, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, False)§§    def create_minion(self, player):§        return Minion(2, 2, taunt=True)§
class HolyWrath(SpellCard):§    def __init__(self):§        super().__init__("Holy Wrath", 5, CHARACTER_CLASS.PALADIN, CARD_RARITY.RARE, target_func=hearthbreaker.targeting.find_spell_target)§§    def use(self, player, game):§        super().use(player, game)§§        fatigue = False§        if player.deck.left == 0:§            fatigue = True§§        player.draw()§        if not fatigue:§            cost = player.hand[-1].mana§            self.target.damage(player.effective_spell_damage(cost), self)§
class Infernal(MinionCard):§    def __init__(self):§        super().__init__("Infernal", 6, CHARACTER_CLASS.WARLOCK, CARD_RARITY.COMMON, False, minion_type=MINION_TYPE.DEMON)§§    def create_minion(self, player):§        return Minion(6, 6)§
class KirinTorMage(MinionCard):§    def __init__(self):§        super().__init__("Kirin Tor Mage", 3, CHARACTER_CLASS.MAGE, CARD_RARITY.RARE, battlecry=Battlecry(GiveAura([AuraUntil(ManaChange(-100), CardSelector(condition=IsSecret()), CardPlayed(IsSecret()))]), PlayerSelector()))§§    def create_minion(self, player):§        return Minion(4, 3)§
class Lightwarden(MinionCard):§    def __init__(self):§        super().__init__("Lightwarden", 1, CHARACTER_CLASS.ALL, CARD_RARITY.RARE)§§    def create_minion(self, player):§        return Minion(1, 2, effects=[Effect(CharacterHealed(player=BothPlayer()), ActionTag(Give(ChangeAttack(2)), SelfSelector()))])§
class ManaWraith(MinionCard):§    def __init__(self):§        super().__init__("Mana Wraith", 2, CHARACTER_CLASS.ALL, CARD_RARITY.RARE)§§    def create_minion(self, player):§        return Minion(2, 2, auras=[Aura(ManaChange(1), CardSelector(BothPlayer(), IsMinion()))])§
class Misdirection(SecretCard):§    def __init__(self):§        super().__init__("Misdirection", 2, CHARACTER_CLASS.HUNTER, CARD_RARITY.RARE)§§    def activate(self, player):§        player.opponent.bind("character_attack", self._reveal)§§    def deactivate(self, player):§        player.opponent.unbind("character_attack", self._reveal)§§    def _reveal(self, character, target):§        if isinstance(target, Hero) and not character.removed:§            game = character.player.game§            possibilities = copy.copy(game.current_player.minions)§            possibilities.extend(game.other_player.minions)§            possibilities.append(game.current_player.hero)§            possibilities.append(game.other_player.hero)§            possibilities.remove(character.current_target)§            character.current_target = game.random_choice(possibilities)§§            super().reveal()§
class NobleSacrifice(SecretCard):§    def __init__(self):§        super().__init__("Noble Sacrifice", 1, CHARACTER_CLASS.PALADIN, CARD_RARITY.COMMON)§§    def _reveal(self, attacker, target):§        player = attacker.player.game.other_player§        if len(player.minions) < 7 and not attacker.removed:§            from hearthbreaker.cards.minions.paladin import DefenderMinion§            defender = DefenderMinion()§            defender.summon(player, player.game, len(player.minions))§            attacker.current_target = player.minions[-1]§            super().reveal()§§    def activate(self, player):§        player.opponent.bind("character_attack", self._reveal)§§    def deactivate(self, player):§        player.opponent.unbind("character_attack", self._reveal)§
class PowerOfTheWild(SpellCard):§    def __init__(self):§        super().__init__("Power of the Wild", 2, CHARACTER_CLASS.DRUID, CARD_RARITY.COMMON)§§    def use(self, player, game):§        super().use(player, game)§        option = player.agent.choose_option([LeaderOfThePack(), SummonPanther()], player)§        option.use(player, game)§
class Redemption(SecretCard):§    def __init__(self):§        super().__init__("Redemption", 1, CHARACTER_CLASS.PALADIN, CARD_RARITY.COMMON)§§    def _reveal(self, minion, by):§        resurrection = minion.card.summon(minion.player, minion.game, min(minion.index, len(minion.player.minions)))§        if resurrection:§            resurrection.health = 1§            super().reveal()§§    def activate(self, player):§        player.bind("minion_died", self._reveal)§§    def deactivate(self, player):§        player.unbind("minion_died", self._reveal)§
class ShadowMadness(SpellCard):§    def __init__(self):§        super().__init__("Shadow Madness", 4, CHARACTER_CLASS.PRIEST, CARD_RARITY.RARE, target_func=hearthbreaker.targeting.find_enemy_minion_spell_target, filter_func=lambda target: target.calculate_attack() <= 3 and target.spell_targetable())§§    def use(self, player, game):§§        super().use(player, game)§§        minion = self.target.copy(player)§        minion.active = True§        minion.exhausted = False§§        self.target.remove_from_board()§        minion.add_to_board(len(player.minions))§§        minion.add_buff(BuffUntil(Stolen(), TurnEnded()))§§    def can_use(self, player, game):§        return super().can_use(player, game) and len(player.minions) < 7§
class SiphonSoul(SpellCard):§    def __init__(self):§        super().__init__("Siphon Soul", 6, CHARACTER_CLASS.WARLOCK, CARD_RARITY.RARE, target_func=hearthbreaker.targeting.find_minion_spell_target)§§    def use(self, player, game):§        super().use(player, game)§        self.target.die(self)§        player.hero.heal(player.effective_heal_power(3), self)§
class Spellbender(SecretCard):§    def __init__(self):§        super().__init__("Spellbender", 3, CHARACTER_CLASS.MAGE, CARD_RARITY.EPIC)§        self.player = None§§    def _reveal(self, card, index):§        if card.is_spell() and len(self.player.minions) < 7 and card.target and card.target.is_minion():§            SpellbenderMinion().summon(self.player, self.player.game, len(self.player.minions))§            card.target = self.player.minions[-1]§            super().reveal()§§    def activate(self, player):§        player.game.current_player.bind("card_played", self._reveal)§        self.player = player§§    def deactivate(self, player):§        player.game.current_player.unbind("card_played", self._reveal)§        self.player = None§
class SummoningPortal(MinionCard):§    def __init__(self):§        super().__init__("Summoning Portal", 4, CHARACTER_CLASS.WARLOCK, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(0, 4, auras=[Aura(ManaChange(-2, 1, minimum=1), CardSelector(condition=IsMinion()))])§
class ThrallmarFarseer(MinionCard):§    def __init__(self):§        super().__init__("Thrallmar Farseer", 3, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(2, 3, windfury=True)§
class Upgrade(SpellCard):§    def __init__(self):§        super().__init__("Upgrade!", 1, CHARACTER_CLASS.WARRIOR, CARD_RARITY.RARE)§§    def use(self, player, game):§        super().use(player, game)§        from hearthbreaker.cards.weapons.warrior import HeavyAxe§        if player.weapon:§            player.weapon.durability += 1§            player.weapon.base_attack += 1§        else:§            heavy_axe = HeavyAxe().create_weapon(player)§            heavy_axe.equip(player)§
class Wisp(MinionCard):§    def __init__(self):§        super().__init__("Wisp", 0, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON)§§    def create_minion(self, player):§        return Minion(1, 1)§
class BlackWhelp(MinionCard):§    def __init__(self):§        super().__init__("Black Whelp", 1, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, False, MINION_TYPE.DRAGON)§§    def create_minion(self, player):§        return Minion(2, 1)§
class DragonkinSorcerer(MinionCard):§    def __init__(self):§        super().__init__("Dragonkin Sorcerer", 4, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, minion_type=MINION_TYPE.DRAGON)§§    def create_minion(self, player):§        return Minion(3, 5, effects=[Effect(SpellTargeted(), [ActionTag(Give([Buff(ChangeAttack(1)), Buff(ChangeHealth(1))]), SelfSelector())])])§
class HungryDragon(MinionCard):§    def __init__(self):§        super().__init__("Hungry Dragon", 4, CHARACTER_CLASS.ALL, CARD_RARITY.COMMON, minion_type=MINION_TYPE.DRAGON, battlecry=(Battlecry(Summon(CardQuery(conditions=[ManaCost(1), IsMinion()])), PlayerSelector(EnemyPlayer()))))§§    def create_minion(self, player):§        return Minion(5, 6)§
class SolemnVigil(SpellCard):§    def __init__(self):§        super().__init__("Solemn Vigil", 5, CHARACTER_CLASS.PALADIN, CARD_RARITY.COMMON, buffs=[Buff(ManaChange(Count(DeadMinionSelector(players=BothPlayer())), -1))])§§    def use(self, player, game):§        super().use(player, game)§        for n in range(0, 2):§            player.draw()§
